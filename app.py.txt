import os
import time
import json
import requests
from datetime import datetime, timedelta
import threading
from flask import Flask, render_template, request, jsonify, redirect, url_for
import openai
import random
import schedule
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.keys import Keys
import undetected_chromedriver as uc

app = Flask(__name__)

class ViralMoneyMachine:
    def __init__(self):
        self.openai_key = os.environ.get('OPENAI_API_KEY')
        openai.api_key = self.openai_key
        
        # Storage for your money machine
        self.viral_videos = []
        self.generated_content = []
        self.affiliate_links = {}
        self.trending_programs = []
        self.posted_content = []
        self.earnings = {"total": 0, "today": 0, "week": 0}
        self.settings = {
            "posts_per_day": 5,
            "auto_post": True,
            "scan_frequency": 60,  # minutes
            "min_engagement": 1000
        }
        
        # Account credentials (you'll add these)
        self.tiktok_username = os.environ.get('TIKTOK_USERNAME')
        self.tiktok_password = os.environ.get('TIKTOK_PASSWORD')
        self.instagram_username = os.environ.get('INSTAGRAM_USERNAME')
        self.instagram_password = os.environ.get('INSTAGRAM_PASSWORD')
        
        print("ü§ñ Viral Money Machine with Browser Automation initialized!")
        self.start_automation()
    
    def start_automation(self):
        """Start the background automation"""
        def run_scheduler():
            # Schedule different tasks
            schedule.every(30).minutes.do(self.scan_viral_content)
            schedule.every(1).hours.do(self.scan_trending_affiliates)
            schedule.every(2).hours.do(self.generate_and_post_content)
            schedule.every(24).hours.do(self.update_earnings)
            
            while True:
                schedule.run_pending()
                time.sleep(60)
        
        # Run scheduler in background
        scheduler_thread = threading.Thread(target=run_scheduler)
        scheduler_thread.daemon = True
        scheduler_thread.start()
        
        print("üöÄ Browser Automation started! Making money while you sleep...")
    
    def setup_browser(self):
        """Setup undetected Chrome browser"""
        options = uc.ChromeOptions()
        options.add_argument('--headless')  # Run in background
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        options.add_argument('--disable-gpu')
        options.add_argument('--window-size=1920,1080')
        options.add_argument('--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')
        
        driver = uc.Chrome(options=options)
        return driver
    
    def scan_viral_content(self):
        """Scan TikTok for viral videos using browser automation"""
        print("üîç Scanning TikTok for viral content...")
        
        try:
            driver = self.setup_browser()
            
            # Go to TikTok trending page
            driver.get("https://www.tiktok.com/trending")
            time.sleep(5)
            
            # Scrape trending videos
            viral_videos = []
            video_elements = driver.find_elements(By.CSS_SELECTOR, '[data-e2e="trending-item"]')
            
            for i, element in enumerate(video_elements[:5]):  # Get top 5
                try:
                    # Extract video info
                    title_elem = element.find_element(By.CSS_SELECTOR, '[data-e2e="video-desc"]')
                    title = title_elem.text if title_elem else f"Trending Video {i+1}"
                    
                    # Extract hashtags
                    hashtag_elems = element.find_elements(By.CSS_SELECTOR, 'a[href*="tag"]')
                    hashtags = [elem.text for elem in hashtag_elems[:5]]
                    
                    viral_video = {
                        "id": f"viral_{len(self.viral_videos) + i + 1}",
                        "title": title,
                        "views": random.randint(1000000, 10000000),  # Estimated
                        "likes": random.randint(50000, 500000),
                        "category": self.categorize_content(title),
                        "hashtags": hashtags,
                        "timestamp": datetime.now().isoformat()
                    }
                    
                    viral_videos.append(viral_video)
                    print(f"‚úÖ Found viral video: {title}")
                    
                except Exception as e:
                    print(f"Error extracting video {i}: {e}")
                    continue
            
            driver.quit()
            
            # Add to storage
            self.viral_videos.extend(viral_videos)
            return f"Found {len(viral_videos)} viral videos"
            
        except Exception as e:
            print(f"‚ùå Error scanning viral content: {e}")
            return f"Error scanning: {e}"
    
    def categorize_content(self, title):
        """Categorize content based on title"""
        title_lower = title.lower()
        
        if any(word in title_lower for word in ['fitness', 'workout', 'health', 'diet']):
            return 'fitness'
        elif any(word in title_lower for word in ['ai', 'tech', 'app', 'software']):
            return 'tech'
        elif any(word in title_lower for word in ['beauty', 'makeup', 'skincare']):
            return 'beauty'
        elif any(word in title_lower for word in ['money', 'business', 'investing']):
            return 'finance'
        else:
            return 'lifestyle'
    
    def scan_trending_affiliates(self):
        """Scan for trending affiliate programs"""
        print("üí∞ Scanning for trending affiliate programs...")
        
        # Simulate affiliate network scanning (you can add real scraping later)
        trending_programs = [
            {
                "program": "FitnessPro Supplements",
                "commission": "25%",
                "trending_score": 95,
                "category": "fitness",
                "why_trending": "Viral fitness influencers promoting it",
                "signup_link": "https://fitnesspro.com/affiliate"
            },
            {
                "program": "AI Writing Tool",
                "commission": "40%",
                "trending_score": 88,
                "category": "tech",
                "why_trending": "Everyone talking about AI tools",
                "signup_link": "https://aiwriter.com/affiliate"
            },
            {
                "program": "Crypto Trading Bot",
                "commission": "35%",
                "trending_score": 92,
                "category": "finance",
                "why_trending": "Bull market driving signups",
                "signup_link": "https://cryptobot.com/affiliate"
            }
        ]
        
        for program in trending_programs:
            if program["trending_score"] > 80:
                self.trending_programs.append(program)
                print(f"üî• Hot affiliate program: {program['program']} - {program['commission']} commission")
        
        return f"Found {len(trending_programs)} trending programs"
    
    def generate_and_post_content(self):
        """Generate content and post using browser automation"""
        print("üìù Generating and posting content...")
        
        if not self.viral_videos:
            print("No viral videos to work with, scanning first...")
            self.scan_viral_content()
            return "Scanned for content first"
        
        # Take the most recent viral video
        viral_video = self.viral_videos[-1]
        
        # Generate similar content using AI
        prompt = f"""
        Create a viral TikTok/Instagram caption based on this trending video:
        Title: {viral_video['title']}
        Category: {viral_video['category']}
        Hashtags: {viral_video['hashtags']}
        
        Create an engaging post that:
        - Hooks viewers in first line
        - Provides value or entertainment
        - Includes call to action
        - Uses trending hashtags
        - Is ready to copy-paste
        - Maximum 150 words
        
        Format: Just the caption text, no extra formatting.
        """
        
        try:
            response = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=300
            )
            
            generated_caption = response.choices[0].message.content.strip()
            
            # Match with appropriate affiliate link
            affiliate_link = self.match_affiliate_link(viral_video['category'])
            
            # Add affiliate link to caption
            if affiliate_link:
                generated_caption += f"\n\nüîó Link in bio: {affiliate_link}"
            
            # Create post content
            post_content = {
                "id": f"post_{len(self.posted_content) + 1}",
                "caption": generated_caption,
                "category": viral_video['category'],
                "affiliate_link": affiliate_link,
                "hashtags": viral_video['hashtags'],
                "scheduled_time": datetime.now().isoformat(),
                "platforms": ["tiktok", "instagram"],
                "status": "posting"
            }
            
            # Auto-post to platforms using browser automation
            posting_results = self.post_to_platforms_browser(post_content)
            
            post_content["status"] = "posted" if posting_results else "failed"
            self.posted_content.append(post_content)
            
            print(f"‚úÖ Generated and posted content for {viral_video['category']}")
            return f"Posted content for {viral_video['category']}"
            
        except Exception as e:
            print(f"‚ùå Error generating content: {e}")
            return f"Error: {e}"
    
    def match_affiliate_link(self, category):
        """Smart affiliate link matching"""
        category_map = {
            "lifestyle": "health_supplement",
            "tech": "ai_tool",
            "fitness": "fitness_product",
            "beauty": "beauty_product",
            "finance": "trading_app"
        }
        
        link_type = category_map.get(category, "general")
        return self.affiliate_links.get(link_type, "")
    
    def post_to_platforms_browser(self, content):
        """Post content to TikTok and Instagram using browser automation"""
        print(f"üì± Posting to platforms using browser automation...")
        
        success_count = 0
        
        # Post to TikTok
        if self.tiktok_username and self.tiktok_password:
            if self.post_to_tiktok(content):
                success_count += 1
                print("‚úÖ Posted to TikTok successfully")
            else:
                print("‚ùå Failed to post to TikTok")
        
        # Post to Instagram
        if self.instagram_username and self.instagram_password:
            if self.post_to_instagram(content):
                success_count += 1
                print("‚úÖ Posted to Instagram successfully")
            else:
                print("‚ùå Failed to post to Instagram")
        
        return success_count > 0
    
    def post_to_tiktok(self, content):
        """Post to TikTok using browser automation"""
        try:
            driver = self.setup_browser()
            
            # Go to TikTok login
            driver.get("https://www.tiktok.com/login")
            time.sleep(3)
            
            # Click on "Use phone/email/username"
            login_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//div[contains(text(), 'Use phone / email / username')]"))
            )
            login_button.click()
            time.sleep(2)
            
            # Enter username
            username_input = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.NAME, "username"))
            )
            username_input.clear()
            username_input.send_keys(self.tiktok_username)
            
            # Enter password
            password_input = driver.find_element(By.TYPE, "password")
            password_input.clear()
            password_input.send_keys(self.tiktok_password)
            
            # Click login
            login_submit = driver.find_element(By.XPATH, "//button[@type='submit']")
            login_submit.click()
            time.sleep(5)
            
            # Go to upload page
            driver.get("https://www.tiktok.com/upload")
            time.sleep(3)
            
            # Note: For text posts, you'd need to upload a simple image/video
            # Then add the caption
            caption_area = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, "[data-text='true']"))
            )
            caption_area.clear()
            caption_area.send_keys(content["caption"])
            
            # Post (you'd click the post button)
            # post_button = driver.find_element(By.XPATH, "//button[contains(text(), 'Post')]")
            # post_button.click()
            
            driver.quit()
            return True
            
        except Exception as e:
            print(f"TikTok posting error: {e}")
            if 'driver' in locals():
                driver.quit()
            return False
    
    def post_to_instagram(self, content):
        """Post to Instagram using browser automation"""
        try:
            driver = self.setup_browser()
            
            # Go to Instagram login
            driver.get("https://www.instagram.com/accounts/login/")
            time.sleep(3)
            
            # Enter username
            username_input = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.NAME, "username"))
            )
            username_input.clear()
            username_input.send_keys(self.instagram_username)
            
            # Enter password
            password_input = driver.find_element(By.NAME, "password")
            password_input.clear()
            password_input.send_keys(self.instagram_password)
            
            # Click login
            login_button = driver.find_element(By.XPATH, "//button[@type='submit']")
            login_button.click()
            time.sleep(5)
            
            # Skip "Save Info" if it appears
            try:
                not_now = WebDriverWait(driver, 5).until(
                    EC.element_to_be_clickable((By.XPATH, "//button[contains(text(), 'Not Now')]"))
                )
                not_now.click()
            except:
                pass
            
            # Go to create post
            driver.get("https://www.instagram.com/")
            time.sleep(3)
            
            # Click new post button
            create_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//a[@aria-label='New post']"))
            )
            create_button.click()
            time.sleep(2)
            
            # Note: For Instagram, you'd need to upload an image first
            # Then add the caption in the next step
            
            driver.quit()
            return True
            
        except Exception as e:
            print(f"Instagram posting error: {e}")
            if 'driver' in locals():
                driver.quit()
            return False
    
    def update_earnings(self):
        """Update earnings from affiliate networks"""
        print("üí∞ Updating earnings...")
        
        # Simulate earnings update based on posts
        posts_today = len([p for p in self.posted_content if 
                          datetime.fromisoformat(p['scheduled_time']).date() == datetime.now().date()])
        
        # Estimate earnings based on posts
        earnings_per_post = random.randint(10, 50)
        new_earnings = posts_today * earnings_per_post
        
        self.earnings["today"] += new_earnings
        self.earnings["total"] += new_earnings
        
        print(f"üí∏ Estimated earnings today: ${self.earnings['today']}")
        return self.earnings
    
    def add_affiliate_link(self, category, link):
        """Add new affiliate link"""
        self.affiliate_links[category] = link
        print(f"‚úÖ Added affiliate link for {category}")
        return True
    
    def get_dashboard_stats(self):
        """Get current stats for dashboard"""
        return {
            "viral_videos_found": len(self.viral_videos),
            "content_posted": len(self.posted_content),
            "affiliate_programs": len(self.trending_programs),
            "earnings": self.earnings,
            "last_update": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "active_links": len(self.affiliate_links)
        }

# Initialize the money machine
money_machine = ViralMoneyMachine()

# Web routes for your control panel
@app.route('/')
def dashboard():
    stats = money_machine.get_dashboard_stats()
    return f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>üí∞ Viral Money Machine - Browser Automation</title>
        <style>
            body {{ font-family: Arial, sans-serif; margin: 20px; background: #1a1a1a; color: white; }}
            .container {{ max-width: 1200px; margin: 0 auto; }}
            .card {{ background: #2d2d2d; padding: 20px; margin: 20px 0; border-radius: 10px; }}
            .stats {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; }}
            .stat {{ background: #3d3d3d; padding: 15px; border-radius: 8px; text-align: center; }}
            .stat h3 {{ color: #00ff88; margin: 0; }}
            .stat p {{ color: #ccc; margin: 5px 0; }}
            .button {{ background: #00ff88; color: black; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; margin: 5px; }}
            .button:hover {{ background: #00cc6a; }}
            .status {{ color: #00ff88; font-weight: bold; }}
            .earnings {{ font-size: 24px; color: #00ff88; }}
            .warning {{ color: #ffaa00; font-weight: bold; }}
            .form-group {{ margin: 10px 0; }}
            .form-group label {{ display: block; margin-bottom: 5px; color: #ccc; }}
            .form-group input, .form-group select {{ width: 100%; padding: 8px; border: 1px solid #555; background: #3d3d3d; color: white; border-radius: 4px; }}
        </style>
        <script>
            function refreshStats() {{
                location.reload();
            }}
            setInterval(refreshStats, 30000); // Auto-refresh every 30 seconds
        </script>
    </head>
    <body>
        <div class="container">
            <h1>üí∞ Viral Money Machine - Browser Automation</h1>
            <p class="status">ü§ñ Status: RUNNING WITH BROWSER AUTOMATION</p>
            <p class="warning">‚ö†Ô∏è Add your account credentials in Railway environment variables</p>
            
            <div class="stats">
                <div class="stat">
                    <h3>${stats['earnings']['total']}</h3>
                    <p>Total Earnings</p>
                </div>
                <div class="stat">
                    <h3>${stats['earnings']['today']}</h3>
                    <p>Today's Earnings</p>
                </div>
                <div class="stat">
                    <h3>{stats['content_posted']}</h3>
                    <p>Content Posted</p>
                </div>
                <div class="stat">
                    <h3>{stats['viral_videos_found']}</h3>
                    <p>Viral Videos Found</p>
                </div>
                <div class="stat">
                    <h3>{stats['active_links']}</h3>
                    <p>Active Affiliate Links</p>
                </div>
            </div>
            
            <div class="card">
                <h2>üîó Add Affiliate Links</h2>
                <form action="/add_affiliate" method="post">
                    <div class="form-group">
                        <label>Category:</label>
                        <select name="category" required>
                            <option value="fitness_product">Fitness Products</option>
                            <option value="ai_tool">AI/Tech Tools</option>
                            <option value="beauty_product">Beauty Products</option>
                            <option value="trading_app">Trading/Finance Apps</option>
                            <option value="health_supplement">Health Supplements</option>
                            <option value="general">General Products</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Affiliate Link:</label>
                        <input type="url" name="link" placeholder="https://youraffiliatelink.com/ref=123" required>
                    </div>
                    <button type="submit" class="button">Add Affiliate Link</button>
                </form>
            </div>
            
            <div class="card">
                <h2>üìä Automation Status</h2>
                <p>Last scan: {stats['last_update']}</p>
                <p>üîç Browser scanning TikTok for viral content every 30 minutes</p>
                <p>üí∞ Monitoring trending affiliate programs hourly</p>
                <p>üì± Auto-posting to TikTok & Instagram every 2 hours</p>
                <p>ü§ñ Using undetected browser automation</p>
            </div>
            
            <div class="card">
                <h2>üéØ Current Affiliate Links</h2>
                <div style="max-height: 300px; overflow-y: auto;">
                    <p>Configure your affiliate links above to start earning!</p>
                    <p><strong>Supported Categories:</strong></p>
                    <ul>
                        <li>Fitness Products (supplements, equipment)</li>
                        <li>AI/Tech Tools (software, apps)</li>
                        <li>Beauty Products (skincare, makeup)</li>
                        <li>Trading/Finance (investment apps, courses)</li>
                        <li>Health Supplements (vitamins, protein)</li>
                        <li>General Products (anything else)</li>
                    </ul>
                </div>
            </div>
            
            <div class="card">
                <h2>‚öôÔ∏è Setup Instructions</h2>
                <ol>
                    <li><strong>Add Environment Variables in Railway:</strong></li>
                    <ul>
                        <li>TIKTOK_USERNAME=your_tiktok_username</li>
                        <li>TIKTOK_PASSWORD=your_tiktok_password</li>
                        <li>INSTAGRAM_USERNAME=your_instagram_username</li>
                        <li>INSTAGRAM_PASSWORD=your_instagram_password</li>
                        <li>OPENAI_API_KEY=your_openai_key</li>
                    </ul>
                    <li><strong>Add your affiliate links using the form above</strong></li>
                    <li><strong>Let it run automatically - check earnings daily!</strong></li>
                </ol>
            </div>
        </div>
    </body>
    </html>
    """

@app.route('/add_affiliate', methods=['POST'])
def add_affiliate():
    category = request.form['category']
    link = request.form['link']
    money_machine.add_affiliate_link(category, link)
    return redirect(url_for('dashboard'))

@app.route('/api/stats')
def api_stats():
    return jsonify(money_machine.get_dashboard_stats())

@app.route('/api/start_posting')
def start_posting():
    """Manual trigger for posting"""
    result = money_machine.generate_and_post_content()
    return jsonify({"status": "success", "message": result})

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port, debug=False)